# üìö –°—Ü–µ–Ω–∞—Ä–∏–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è AI Console

–ö–æ–ª–ª–µ–∫—Ü–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è AI Console –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∑–∞–¥–∞—á.

---

## üéì –°—Ü–µ–Ω–∞—Ä–∏–π 1: –°—Ç—É–¥–µ–Ω—Ç —É—á–∏—Ç Python —Å –Ω—É–ª—è

**–¶–µ–ª—å:** –ù–æ–≤–∏—á–æ–∫ —Ö–æ—á–µ—Ç –≤—ã—É—á–∏—Ç—å –æ—Å–Ω–æ–≤—ã Python

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∞—á–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
/context level beginner
‚úì skill_level set to: beginner

/context topic basics
‚úì current_topic set to: basics

/personality encouraging
‚úì Personality set to: encouraging

# –ù–∞—á–∞—Ç—å –æ–±—É—á–µ–Ω–∏–µ
You: What is Python and why should I learn it?

AI Tutor:
Python is a beginner-friendly programming language that...

üí° Suggestions:
  ‚Ä¢ Break down the problem into smaller functions
  ‚Ä¢ Use meaningful variable names

üìö Learning Resources:
  ‚Ä¢ Python Fundamentals
  ‚Ä¢ Why Learn Python in 2025

# –°–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
You: How do I install Python on my computer?

AI Tutor:
Great question! Here's how to install Python on your computer...

# –ê–Ω–∞–ª–∏–∑ –ø–µ—Ä–≤–æ–≥–æ –∫–æ–¥–∞
You: /analyze

Paste your code (type END on a new line to finish):

print("Hello, World!")

END

Code Analysis:
  ‚úì Correct syntax
  ‚úì Good for first program
  
Suggestions:
  ‚Ä¢ Add more print statements
  ‚Ä¢ Experiment with different strings
```

---

## üíº –°—Ü–µ–Ω–∞—Ä–∏–π 2: –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –≥–æ—Ç–æ–≤–∏—Ç—Å—è –∫ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—é

**–¶–µ–ª—å:** –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–º—É –∏–Ω—Ç–µ—Ä–≤—å—é –Ω–∞ –ø–æ–∑–∏—Ü–∏—é Middle Backend Developer

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π —É—Ä–æ–≤–µ–Ω—å
/context level advanced
‚úì skill_level set to: advanced

/context topic algorithms
‚úì current_topic set to: algorithms

/context language python
‚úì language set to: python

/personality analytical
‚úì Personality set to: analytical

# –°–ø—Ä–æ—Å–∏—Ç—å –æ —Å–ª–æ–∂–Ω–æ–º –∞–ª–≥–æ—Ä–∏—Ç–º–µ
You: Explain the difference between DFS and BFS, and when to use each

AI Tutor:
DFS (Depth-First Search) and BFS (Breadth-First Search) are fundamental graph traversal algorithms.

Time Complexity: Both O(V + E)
Space Complexity: DFS O(h), BFS O(V)

Use DFS when:
- Finding connected components
- Topological sorting
- Detecting cycles

Use BFS when:
- Shortest path in unweighted graphs
- Level-order traversal
- Finding nearest node

üí° Suggestions:
  ‚Ä¢ Implement both algorithms
  ‚Ä¢ Practice with LeetCode problems

# –ü—Ä–∞–∫—Ç–∏–∫–∞ —Å –∫–æ–¥–æ–º
You: /analyze

Paste your code (type END on a new line to finish):

from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        node = queue.popleft()
        print(node, end=' ')
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

END

Code Analysis:

Algorithm: BFS (Breadth-First Search)
Time Complexity: O(V + E) - Optimal for this operation
Space Complexity: O(V) - Queue stores at most V nodes

Code Quality: ‚úì Excellent
  ‚Ä¢ Clear variable names
  ‚Ä¢ Correct algorithm implementation
  ‚Ä¢ Proper use of deque

Suggestions:
  ‚Ä¢ Add function docstring
  ‚Ä¢ Handle edge cases (empty graph)
  ‚Ä¢ Add type hints for Python 3.9+
```

---

## üîß –°—Ü–µ–Ω–∞—Ä–∏–π 3: Code Review —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞

**–¶–µ–ª—å:** –ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –∫–æ–¥–∞

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —Ä–µ—Ü–µ–Ω–∑–∏—Ä–æ–≤–∞–Ω–∏—è
/context level intermediate
‚úì skill_level set to: intermediate

/context topic code-quality
‚úì current_topic set to: code-quality

/personality analytical
‚úì Personality set to: analytical

# –ê–Ω–∞–ª–∏–∑ –∫–æ–¥–∞ –ø—Ä–æ–µ–∫—Ç–∞
You: /analyze

Paste your code (type END on a new line to finish):

class User:
    def __init__(self, name, email, password):
        self.name = name
        self.email = email
        self.password = password
    
    def validate_email(self):
        if '@' in self.email:
            return True
        return False
    
    def validate_password(self):
        if len(self.password) >= 8:
            return True
        return False
    
    def save_to_db(self):
        # TODO: implement database saving
        pass

END

Code Analysis:

Code Quality Issues:
  ‚Ä¢ Missing docstrings
  ‚Ä¢ No input validation in __init__
  ‚Ä¢ Storing password in plaintext (SECURITY RISK!)
  ‚Ä¢ Methods should be more DRY

Suggestions:
  ‚Ä¢ Use regex for email validation
  ‚Ä¢ Hash passwords with bcrypt
  ‚Ä¢ Combine validators into single method
  ‚Ä¢ Add type hints

üìö Learning Resources:
  ‚Ä¢ Secure Password Storage
  ‚Ä¢ Email Validation Best Practices
  ‚Ä¢ Object-Oriented Design Patterns

# –°–ª–µ–¥—É—é—â–∞—è –ø—Ä–æ–±–ª–µ–º–∞
You: What's the best way to handle authentication in a web application?

AI Tutor:
Authentication is critical for security. Here are the best practices...
```

---

## üéØ –°—Ü–µ–Ω–∞—Ä–∏–π 4: –ü–æ–º–æ—â—å —Å –¥–æ–º–∞—à–Ω–∏–º –∑–∞–¥–∞–Ω–∏–µ–º

**–¶–µ–ª—å:** –°—Ç—É–¥–µ–Ω—Ç –∑–∞—Å—Ç—Ä—è–ª –Ω–∞ –∑–∞–¥–∞—á–µ, –Ω—É–∂–Ω—ã –ø–æ–¥—Å–∫–∞–∑–∫–∏

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç
/context level beginner
‚úì skill_level set to: beginner

/context topic loops
‚úì current_topic set to: loops

/personality encouraging
‚úì Personality set to: encouraging

# –°–ø—Ä–æ—Å–∏—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫—É
You: I need to write a function that prints numbers from 1 to 10, but I don't know how to do it

AI Tutor:
Great question! This is a perfect opportunity to learn about loops.

You have two options:

1. For Loop (most common for counting):
   for i in range(1, 11):
       print(i)

2. While Loop (good for conditions):
   i = 1
   while i <= 10:
       print(i)
       i += 1

üí° Suggestions:
  ‚Ä¢ Try both approaches
  ‚Ä¢ Understand range() function
  ‚Ä¢ Notice the difference in syntax

üìö Learning Resources:
  ‚Ä¢ Understanding Python's range() function
  ‚Ä¢ For Loops vs While Loops

# –°—Ç—É–¥–µ–Ω—Ç –ø–æ–ø—Ä–æ–±–æ–≤–∞–ª –∏ —Ö–æ—á–µ—Ç —É–ª—É—á—à–∏—Ç—å
You: Now I need to print only even numbers from 1 to 20

You: /analyze

Paste your code (type END on a new line to finish):

for i in range(1, 21):
    if i % 2 == 0:
        print(i)

END

Code Analysis:

Code: ‚úì Correct!

Algorithm:
  ‚Ä¢ Range from 1 to 20
  ‚Ä¢ Check if divisible by 2 (modulo operator)
  ‚Ä¢ Print if condition is true

Suggestions:
  ‚Ä¢ Could use range(2, 21, 2) for efficiency
  ‚Ä¢ Try list comprehension: [i for i in range(1, 21) if i % 2 == 0]

üí° Educational Value:
  ‚Ä¢ You understand conditionals
  ‚Ä¢ You understand modulo operator
  ‚Ä¢ Next: Learn about step parameter in range()
```

---

## üèóÔ∏è –°—Ü–µ–Ω–∞—Ä–∏–π 5: –ê—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –Ω–æ–≤—É—é –∏–¥–µ—é

**–¶–µ–ª—å:** –û–±—Å—É–¥–∏—Ç—å –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
/context level advanced
‚úì skill_level set to: advanced

/context topic architecture
‚úì current_topic set to: architecture

/personality creative
‚úì Personality set to: creative

# –û–±—Å—É–¥–∏—Ç—å –∏–¥–µ—é
You: I'm thinking about using microservices architecture for a new project. What are the pros and cons?

AI Tutor:
Microservices is an interesting architectural choice!

Advantages:
  ‚Ä¢ Independent scaling of services
  ‚Ä¢ Technology flexibility per service
  ‚Ä¢ Faster deployment cycles
  ‚Ä¢ Better fault isolation

Disadvantages:
  ‚Ä¢ Distributed system complexity
  ‚Ä¢ Network latency concerns
  ‚Ä¢ Data consistency challenges
  ‚Ä¢ Operational overhead

When to use:
  ‚Ä¢ Large teams working on different domains
  ‚Ä¢ Services with different scaling needs
  ‚Ä¢ Technology heterogeneity requirement

üí° Suggestions:
  ‚Ä¢ Consider message queues (RabbitMQ, Kafka)
  ‚Ä¢ Implement service discovery
  ‚Ä¢ Plan for monitoring and logging

# –û–±—Å—É–¥–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π
You: Our team is 5 people. Is microservices overkill?

AI Tutor:
For a team of 5, I'd lean towards a monolithic architecture first...
```

---

## üß™ –°—Ü–µ–Ω–∞—Ä–∏–π 6: QA –∏–Ω–∂–µ–Ω–µ—Ä –∏—â–µ—Ç –±–∞–≥–∏

**–¶–µ–ª—å:** –û–±—Å—É–¥–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –∏ –±–∞–≥–∏

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç
/context level intermediate
‚úì skill_level set to: intermediate

/context topic testing
‚úì current_topic set to: testing

/personality analytical
‚úì Personality set to: analytical

# –ê–Ω–∞–ª–∏–∑ –±–∞–≥–æ–≤–æ–≥–æ –∫–æ–¥–∞
You: /analyze

Paste your code (type END on a new line to finish):

def calculate_discount(price, discount_percent):
    final_price = price * (1 - discount_percent / 100)
    return final_price

# Test cases
print(calculate_discount(100, 10))  # Expected: 90
print(calculate_discount(100, 0))   # Expected: 100
print(calculate_discount(100, 100)) # Expected: 0
print(calculate_discount(100, 150)) # Expected: -50 (BUG!)

END

Code Analysis:

Issues Found:
  ‚Ä¢ No validation for negative discount_percent
  ‚Ä¢ No validation for negative price
  ‚Ä¢ Allows discount > 100% (resulting in negative price)

Edge Cases NOT Handled:
  ‚Ä¢ discount_percent > 100%
  ‚Ä¢ price < 0
  ‚Ä¢ Non-numeric inputs

Test Failures:
  ‚Ä¢ calculate_discount(100, 150) returns -50 ‚úó

Suggestions:
  ‚Ä¢ Add input validation
  ‚Ä¢ Clamp discount_percent to 0-100%
  ‚Ä¢ Add unit tests
  ‚Ä¢ Handle edge cases

üìö Learning Resources:
  ‚Ä¢ Unit Testing Best Practices
  ‚Ä¢ Defensive Programming
  ‚Ä¢ Property-Based Testing
```

---

## üé® –°—Ü–µ–Ω–∞—Ä–∏–π 7: –§—Ä–æ–Ω—Ç–µ–Ω–¥ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑—É—á–∞–µ—Ç –Ω–æ–≤—ã–π —è–∑—ã–∫

**–¶–µ–ª—å:** –ü–µ—Ä–µ–π—Ç–∏ —Å JavaScript –Ω–∞ TypeScript

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç
/context level intermediate
‚úì skill_level set to: intermediate

/context topic typescript
‚úì current_topic set to: typescript

/context language typescript
‚úì language set to: typescript

/personality practical
‚úì Personality set to: practical

# –°–ø—Ä–æ—Å–∏—Ç—å –æ TypeScript
You: I know JavaScript but want to learn TypeScript. What are the main differences?

AI Tutor:
TypeScript is a superset of JavaScript that adds static typing.

Key Differences:
1. Type Safety
   const name: string = "John";  // Type specified

2. Interfaces
   interface User {
     name: string;
     age: number;
   }

3. Classes (proper OOP)
4. Generics (reusable components)
5. Better IDE support

Benefits in production:
  ‚Ä¢ Catch errors before runtime
  ‚Ä¢ Better code documentation
  ‚Ä¢ Improved refactoring
  ‚Ä¢ Team collaboration

üí° Suggestions:
  ‚Ä¢ Start with simple types (string, number)
  ‚Ä¢ Gradually introduce interfaces
  ‚Ä¢ Use strict mode: "strict": true

üìö Learning Resources:
  ‚Ä¢ TypeScript Handbook
  ‚Ä¢ From JavaScript to TypeScript
  ‚Ä¢ Real-world TypeScript Patterns

# –ê–Ω–∞–ª–∏–∑ –ø–µ—Ä–≤–æ–≥–æ TypeScript –∫–æ–¥–∞
You: /analyze

Paste your code (type END on a new line to finish):

interface User {
  id: number;
  name: string;
  email: string;
}

function getUserInfo(user: User): string {
  return `${user.name} - ${user.email}`;
}

const myUser: User = {
  id: 1,
  name: "Alice",
  email: "alice@example.com"
};

console.log(getUserInfo(myUser));

END

Code Analysis:

Code Quality: ‚úì Excellent
  ‚Ä¢ Proper interface definition
  ‚Ä¢ Type annotations on parameters
  ‚Ä¢ Return type specified
  ‚Ä¢ Correct implementation

TypeScript Features Used:
  ‚Ä¢ Interface for type safety
  ‚Ä¢ Function parameter typing
  ‚Ä¢ Variable typing

Next Steps:
  ‚Ä¢ Learn generics for reusable interfaces
  ‚Ä¢ Explore utility types (Partial, Pick, etc.)
  ‚Ä¢ Experiment with classes
```

---

## üöÄ –°—Ü–µ–Ω–∞—Ä–∏–π 8: –ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏—Ö –≤–æ–ø—Ä–æ—Å–æ–≤

**–¶–µ–ª—å:** –ë—ã—Å—Ç—Ä–æ –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —á–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è FAQ
/personality encouraging
‚úì Personality set to: encouraging

# –í–æ–ø—Ä–æ—Å 1
You: What's the difference between let, const, and var in JavaScript?

AI Tutor:
Great question! This is important to understand...

# –í–æ–ø—Ä–æ—Å 2
You: Why do people say Python is slow?

AI Tutor:
Python is indeed slower than C++, but here's why...

# –í–æ–ø—Ä–æ—Å 3
You: /context language python
You: Should I learn Python or Java?

AI Tutor:
Both are excellent choices. Here's how to decide...

# –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å—ë –≤ –∏—Å—Ç–æ—Ä–∏–∏
You: /history

Conversation History (3 items):
[1] 2025-01-10 14:15:30 - chat
    User: What's the difference between let, const, and var...
[2] 2025-01-10 14:16:15 - chat
    User: Why do people say Python is slow...
[3] 2025-01-10 14:17:45 - chat
    User: Should I learn Python or Java...
```

---

## üíæ –°—Ü–µ–Ω–∞—Ä–∏–π 9: –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤–∞–∂–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏

**–¶–µ–ª—å:** –ó–∞–ø–∏—Å–∞—Ç—å –≤–∞–∂–Ω—ã–π —Å–æ–≤–µ—Ç –≤ –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π —Å—Å—ã–ª–∫–∏

```bash
# –°–µ—Å—Å–∏—è 1: –ò–∑—É—á–µ–Ω–∏–µ
You: /context topic database-design

You: What are database normalization forms?

AI Tutor:
Database normalization is crucial for good data design...

# –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏—Å—Ç–æ—Ä–∏—é –ø–æ—Å–ª–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è
You: /history

# –°–µ—Å—Å–∏—è 2: –í—Å–ø–æ–º–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
You: /history

Conversation History (1 items):

[1] 2025-01-10 14:30:00 - chat
    User: What are database normalization forms...
    
(–í—ã –≤–∏–¥–∏—Ç–µ –æ—Ç–≤–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π –¥–∞–ª –ò–ò)
```

---

## üéì –°—Ü–µ–Ω–∞—Ä–∏–π 10: –û–±—É—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –ø—Ä–∞–∫—Ç–∏–∫—É

**–¶–µ–ª—å:** –®–∫–æ–ª—å–Ω–∏–∫ –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Å–µ—Ä–∏—é –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π

```bash
# –£—Å—Ç–∞–Ω–æ–≤–∫–∞
/context level beginner
/personality encouraging

# –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 1
You: Can you give me a simple exercise to practice loops?

AI Tutor:
Great! Here's an exercise:

Exercise 1:
Write a program that prints a multiplication table for 5...

# –†–µ—à–µ–Ω–∏–µ
You: /analyze

Paste your code (type END on a new line to finish):

for i in range(1, 11):
    print(f"5 x {i} = {5 * i}")

END

Code Analysis: ‚úì Correct!

# –£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ 2
You: Do you have a harder one?

AI Tutor:
Sure! Try this:

Exercise 2:
Write a program that finds prime numbers between 1 and 100...

# –ò —Ç–∞–∫ –¥–∞–ª–µ–µ...
```

---

## üìä –¢–∞–±–ª–∏—Ü–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

| –°—Ü–µ–Ω–∞—Ä–∏–π | –¢–∏–ø | –õ–∏—á–Ω–æ—Å—Ç—å | –£—Ä–æ–≤–µ–Ω—å |
|----------|-----|----------|---------|
| 1. –°—Ç—É–¥–µ–Ω—Ç + Python | üéì –û–±—É—á–µ–Ω–∏–µ | Encouraging | Beginner |
| 2. –ò–Ω—Ç–µ—Ä–≤—å—é | üíº –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π | Analytical | Advanced |
| 3. Code Review | üîß –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ | Analytical | Intermediate |
| 4. –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ | üìö –û–±—É—á–µ–Ω–∏–µ | Encouraging | Beginner |
| 5. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ | üèóÔ∏è –î–∏–∑–∞–π–Ω | Creative | Advanced |
| 6. QA/–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ | üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ | Analytical | Intermediate |
| 7. –ù–æ–≤—ã–π —è–∑—ã–∫ | üé® –û–±—É—á–µ–Ω–∏–µ | Practical | Intermediate |
| 8. FAQ | ‚ùì –ü–æ–º–æ—â—å | Encouraging | Any |
| 9. –ó–∞–º–µ—Ç–∫–∏ | üíæ –°–ø—Ä–∞–≤–∫–∞ | Any | Any |
| 10. –ü—Ä–∞–∫—Ç–∏–∫–∞ | üéì –û–±—É—á–µ–Ω–∏–µ | Encouraging | Beginner |

---

## üéØ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

1. **–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ü–µ–Ω–∞—Ä–∏–π**, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –≤–∞—à–µ–π —Å–∏—Ç—É–∞—Ü–∏–∏
2. **–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç** (`/context`)
3. **–í—ã–±–µ—Ä–∏—Ç–µ –ª–∏—á–Ω–æ—Å—Ç—å** (`/personality`)
4. **–ù–∞—á–Ω–∏—Ç–µ –¥–∏–∞–ª–æ–≥** —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞
5. **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `/analyze`** –¥–ª—è –∫–æ–¥–∞
6. **–°–æ—Ö—Ä–∞–Ω—è–π—Ç–µ `/history`** –ø–æ–ª–µ–∑–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏

---

**–£–¥–∞—á–∏ –≤ –æ–±—É—á–µ–Ω–∏–∏ –∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ!** üöÄ
